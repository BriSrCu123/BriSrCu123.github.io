<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo博客搭建图片无法显示问题</title>
      <link href="/2025/01/20/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/20/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客搭建图片无法显示问题（路径解析错误）"><a href="#Hexo博客搭建图片无法显示问题（路径解析错误）" class="headerlink" title="Hexo博客搭建图片无法显示问题（路径解析错误）"></a>Hexo博客搭建图片无法显示问题（路径解析错误）</h1><h2 id="一、具体问题"><a href="#一、具体问题" class="headerlink" title="一、具体问题"></a>一、具体问题</h2><p>因为图片无法显示的原因有很多，一定要根据自己的具体情况解决问题，不要还没了解自己是不是同一个问题就盲目更改。</p><p>在进行博客文章的发布时，我发现我的使用相对路径加载的图片一直无法显示，而我确实是按照以下步骤设置的相对路径，路径按理来说是没有问题的：</p><ol><li><p>下载hexo-asset-image的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>将根目录下_config.yml中的post_asset_folder设为true，增加同名文件夹，存放照片</p></li><li><p>将照片存放进同名文件夹，路径设置为<code>(./Hexo博客搭建图片无法显示问题/404.png)</code>或<code>(404.png)</code></p></li></ol><p>但是打开博客界面检查，却发现：</p><p><img src="/2025/01/20/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/error.png" alt></p><p>点开图片路径：H</p><p><img src="/2025/01/20/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/404.png" alt></p><p>却发现解析成了<code>(https://blog.brisrcu.cn/2025/01/20/数据结构-线性表.htm/image-20250114144055624.png)</code>按理来说该是<code>(https://blog.brisrcu.cn/2025/01/20/数据结构-线性表/image-20250114144055624.png)</code>   (举例图片不太一样，道理是一样的，主要是没有截404.png报错的图)</p><h2 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h2><p>其实如果遇到的是这个问题，很明显就是<code>.htm</code>干扰了图片加载，只需要在hexo的根目录中在 <code>_config.yml</code> 中修改 <code>permalink</code> 配置为不带文件后缀：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :year/:month/:day/:title/</span><br></pre></td></tr></table></figure><p>在清理重新生成上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>至此，问题就已经解决了，最主要的还是要一步步发现问题到底处在了哪。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构|树</title>
      <link href="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
      <url>/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="五、树"><a href="#五、树" class="headerlink" title="五、树"></a>五、树</h2><h3 id="（一）基本概念"><a href="#（一）基本概念" class="headerlink" title="（一）基本概念"></a>（一）基本概念</h3><p>1.定义：n个节点构成的一个层次结构（n=0,空树，n&gt;0,只有各个节点，其余节点互不相交）</p><p>2.基本术语：<img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/image-20250114144055624.png" alt="image-20250114144055624"></p><ul><li><p><strong>父节点(双亲)</strong>与<strong>子节点(孩子)</strong><br>如A是B、C、D的父节点，B、C、D是A的孩子，除根节点外，每个节点有且只有1个父节点</p></li><li><p><strong>祖先</strong>与<strong>子孙</strong>：如A、B是E的祖先，B、C、D、E、F是A的子孙</p></li><li><p><strong>兄弟</strong>:具有同一父节点，如B、C、D是兄弟</p><p><strong>堂兄弟</strong>：父节点在同一层</p></li><li><p><strong>根节点</strong>：非空树中无前驱节点的结点，1个，无父节点<br><strong>叶节点</strong>：无子节点<br><strong>分支节点</strong>：其余</p></li><li><p>节点的<strong>入度</strong>(ID)：指向节点的分支数目<br>节点的<strong>出度</strong>(OD)：子节点数<br><strong>树的度</strong>(TD)：max(所有节点的出度)<br>如OD(A)=3，OD(B)=1。叶节点的出度为0.<br>根的入度为0，其它各节点的入度=1.</p></li><li><p><code>度=K</code> 的树称为<strong>K叉树</strong>，但二叉树有特定的定义。</p></li><li><p><strong>有序树</strong>:树中任一节点的各子树从左到右有序<br><strong>无序树</strong>:否则</p></li><li><p><strong>森林</strong>(或树林)：m(m≥0)棵互不相交的有序树的有序集合</p></li></ul><p>3.性质：</p><ol><li>树中节点总数n（n≥0）等于树中各节点的出度之和加1 。</li><li>度＝K的树（K叉树）第i(i≥1)层至多有Ki-1个节点。</li><li>深度＝h(h≥1)的K（K＞1）叉树至多有(Kh-1)/(K-1)个节点。</li><li>包含n（n≥0）个节点的K（K＞1）叉树的最小深度为： $\left\lceil \log_K \left( n(K-1) + 1 \right) \right\rceil$</li></ol><h3 id="（二）二叉树"><a href="#（二）二叉树" class="headerlink" title="（二）二叉树"></a>（二）二叉树</h3><p>1.定义：或者是空树， 或者由1个根节点以及左子树和右子树组成，左子树和右子树都是二叉树。</p><p>2.特点：区分左右</p><p>性质：</p><ul><li>二叉树的第i层上至多有$2^{i-1}$个节点（满二叉树），至少得有一个节点</li><li>深度为k的二叉树至多有$2^k-1$个节点（k&gt;=1）</li><li>设二叉树BT中叶节点数为$n_0$，出度为2的节点数为$n_2$，则有：$n_0=n_2+1$</li><li>含有n(n ≥1)个节点的完全二叉树（与满二叉树编号一一对应/除了最后一层外，其余各层的节点都达到了最大数目，且最后一层的所有节点都从左向右连续排列）的深度：$h = \left\lfloor \log_2 n \right\rfloor + 1$<code>2*边 = 入度+出度</code></li><li>编号 略</li></ul><p>3.五种基本形态：</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/image-20250114145701646.png" alt="image-20250114145701646"></p><p>4.案例</p><p>数据压缩问题（编码）、求表达式的解</p><p>5.抽象数据类型定义：略</p><p>D\R\P</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/image-20250114150431823.png" alt="image-20250114150431823"></p><h4 id="6-存储结构"><a href="#6-存储结构" class="headerlink" title="6.存储结构"></a>6.存储结构</h4><p>（1）顺序存储（按满二叉树编号）</p><p>优点：简单</p><p>缺点：不利于增删改；浪费空间，不适合非完全二叉树</p><p>（2）链式存储</p><p>二叉链表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BiNode &#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    BiNode* lchild, * rchild;//n个节点，n+1个空指针域</span><br><span class="line">&#125;;</span><br><span class="line">BiNode* BiTree;</span><br></pre></td></tr></table></figure><p>三叉链表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct TriNode &#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    BiNode* lchild, * rchild,* parent;</span><br><span class="line">&#125;;</span><br><span class="line">BiNode* TriTree;</span><br></pre></td></tr></table></figure><h4 id="7-遍历二叉树"><a href="#7-遍历二叉树" class="headerlink" title="7.遍历二叉树"></a>7.遍历二叉树</h4><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/image-20250114160831061.png" alt="image-20250114160831061"></p><p>（1）前序遍历（DLR）eg.ABELDHMIJ         前缀表达式（波兰式）</p><p>（2）中序遍历（LDR）eg.ELBAMHIDJ         中缀</p><p>（3）后序遍历（LRD）eg.LEBMIHJDA         后缀（逆波兰式）</p><p>反过来，由序列得到二叉树（先序+中序 后序+中序）</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/image-20250114162842704.png" alt="image-20250114162842704"></p><p>实现：利用二叉链表（每个节点经过三次,三种遍历访问时机不同 时间<code>O(n)</code> 空间<code>O(n)</code>）</p><p>(1)递归算法</p><p>（先序遍历）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool PreOrderTraverse(BiTree T)&#123;</span><br><span class="line">    if (T == Null)return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（中序遍历）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool InOrderTraverse(BiTree&amp; T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild);</span><br><span class="line">    visit(T);</span><br><span class="line">    InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（后序遍历）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool PostOrderTarverse(BiTree&amp; T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T == NULL)return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        PostOrderTarverse(T-&gt;lchild);</span><br><span class="line">        PostOrderTarverse(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）非递归算法</p><p>（中序遍历）利用栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool InOrderTraverse(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    p = T;</span><br><span class="line">    while (p || !StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        if (p) &#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            Pop(S, q);</span><br><span class="line">            visit(q);</span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 层次遍历—利用队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void LevelOrderTraverse(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    if (!T)return;</span><br><span class="line">    queue&lt;BiTree&gt; Q;</span><br><span class="line">    Q.push(T);</span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree p = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        if (p-&gt;lchild)Q.push(p-&gt;lchild);</span><br><span class="line">        if (p-&gt;rchild)Q.push(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）建立二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool CreatBiTree(BiTree&amp; T)</span><br><span class="line">&#123;</span><br><span class="line">    TElemType input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    if (input == &#x27;#&#x27;)</span><br><span class="line">        return false;</span><br><span class="line">    T = new BiNode;</span><br><span class="line">    T-&gt;data = input;</span><br><span class="line">    CreatBiTree(T-&gt;lchild);</span><br><span class="line">    CreatBiTree(T-&gt;rchild);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）复制二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool CopyBiTree(const BiTree&amp; T, BiTree&amp; NewT)</span><br><span class="line">&#123;</span><br><span class="line">    if (T == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    NewT = new BiNode;</span><br><span class="line">    NewT-&gt;data = T-&gt;data;</span><br><span class="line">    CopyBiTree(T-&gt;lchild, NewT-&gt;lchild);</span><br><span class="line">    CopyBiTree(T-&gt;rchild, NewT-&gt;rchild);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）计算二叉树深度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int Depth(BiTree &amp;T)</span><br><span class="line">&#123;</span><br><span class="line">    if(T == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int m = Depth(T-&gt;lchild);</span><br><span class="line">    int n = Depth(T-&gt;rchild);</span><br><span class="line">    if(m&gt;n)</span><br><span class="line">        return m+1;</span><br><span class="line">    else</span><br><span class="line">        return n+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（7）计算节点个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int CountNode(BiTree&amp; T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return CountNode(T-&gt;lchild) + CountNode(T-&gt;rchild) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（8）计算叶子节点个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Count0Node(BiTree&amp; T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (T-&gt;lchild == nullptr &amp;&amp; T-&gt;rchild == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Count0Node(T-&gt;lchild) + Count0Node(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-线索二叉树"><a href="#8-线索二叉树" class="headerlink" title="8.线索二叉树"></a>8.线索二叉树</h4><p>利用空指针域（n+1），左孩子为空，将空左孩子指针域指向其前驱，右-&gt;后继</p><p>增设两个标志域，ltag，rtag</p><h3 id="（三）数和森林"><a href="#（三）数和森林" class="headerlink" title="（三）数和森林"></a>（三）数和森林</h3><h3 id="（四）哈夫曼树"><a href="#（四）哈夫曼树" class="headerlink" title="（四）哈夫曼树"></a>（四）哈夫曼树</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构|数组与广义表</title>
      <link href="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/"/>
      <url>/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="四、串、数组和广义表"><a href="#四、串、数组和广义表" class="headerlink" title="四、串、数组和广义表"></a>四、串、数组和广义表</h2><h3 id="（一）串"><a href="#（一）串" class="headerlink" title="（一）串"></a>（一）串</h3><p>零个或多个任意<strong>字符</strong>组成的有限序列</p><p>子串；空串；主串；字符位置；子串位置（第一个字符）；空格串！=空串；串相等 ······略 KMP算法</p><h3 id="（二）数组"><a href="#（二）数组" class="headerlink" title="（二）数组"></a>（二）数组</h3><p>定义：n维同类型元素组成的序列，且连续存储 <code>ElemType array[m][n]</code></p><h4 id="1-数组抽象数据类型"><a href="#1-数组抽象数据类型" class="headerlink" title="1.数组抽象数据类型"></a>1.数组抽象数据类型</h4><p>略</p><h4 id="2-数组的存储结构"><a href="#2-数组的存储结构" class="headerlink" title="2.数组的存储结构"></a>2.数组的存储结构</h4><p>1）静态存储</p><p>行主次序+列主次序</p><p>数组元素地址计算：（起始地址b，每个元素占L个字节）</p><ol><li>一维数组 $Loc(e)=b+i*L$</li><li>二维数组 $Loc(e)=b+(i<em>n+j)</em>L$</li><li>三维数组 $Loc(e)=b+(i<em>n</em>p+j<em>p+k)</em>L$</li><li>n维数组 $Local(e)=b+ \left( \sum_{j=1}^{n-1} i_j \cdot \prod_{k=j+1}^{n} u_k + i_n \right) \cdot L$</li></ol><p>2）动态存储</p><p>n维数组映射到一维数组</p><h4 id="3-特殊矩阵的压缩存储"><a href="#3-特殊矩阵的压缩存储" class="headerlink" title="3.特殊矩阵的压缩存储"></a>3.特殊矩阵的压缩存储</h4><p>1）常规存储：二维存储</p><p>2）对称矩阵：$a_{ij}=a_{ji}$  -&gt; 只存上三角或下三角 -&gt; $n*(n+1)/2$</p><p>存放在一个一维数组，算存储位置$a_{ij}$ </p><p>3）三角矩阵:只存上三角或下三角</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/image-20250114114854644.png" alt="image-20250114114854644"></p><p>4）对角矩阵（三对角矩阵、五对角矩阵······）</p><p>二维矩阵存储</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/image-20250114115458096.png" alt="image-20250114115458096"></p><p>5）稀疏矩阵（只存储非零元素）</p><p>用三元组表</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/image-20250114120323764.png" alt="image-20250114120323764"></p><h4 id="4-三元组表"><a href="#4-三元组表" class="headerlink" title="4.三元组表"></a>4.三元组表</h4><p>存储非零元素，i（行）,j,（列）v（数值），在第三元组表0行存矩阵总行数、总列数、非零元素总个数</p><h4 id="5-十字链表"><a href="#5-十字链表" class="headerlink" title="5.十字链表"></a>5.十字链表</h4><p>优点：灵活的插入、删除、进行矩阵运算</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/image-20250114141506773.png" alt="image-20250114141506773"></p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/image-20250114133726590.png" alt="image-20250114133726590"></p><h3 id="（三）广义表"><a href="#（三）广义表" class="headerlink" title="（三）广义表"></a>（三）广义表</h3><p>定义：n&gt;=0个元素的有限序列，每一个元素或是原子，或是广义表，可以<em>表中套表</em> ，计作$LS=(a_1,a_2,\ldots,a_n)$，</p><ul><li>表头为$a_1$，表尾除了$a_1$外组成的表，</li><li>长度：最外层所含元素个数</li><li>深度：展开后所含括号的重数</li><li>共享：$B=(A)$</li><li>基本运算：GetHead(L),GetTail(L)</li><li>链式结构存储</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构|栈与队列</title>
      <link href="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="三、栈与队列"><a href="#三、栈与队列" class="headerlink" title="三、栈与队列"></a>三、栈与队列</h2><h3 id="（一）栈（stack-LIFO）"><a href="#（一）栈（stack-LIFO）" class="headerlink" title="（一）栈（stack LIFO）"></a>（一）栈（stack LIFO）</h3><p><strong>“先进后出”</strong>：只能在表尾（栈顶）插入（入栈），在表尾（栈底）删除（出栈）</p><h4 id="1-抽象数据类型"><a href="#1-抽象数据类型" class="headerlink" title="1.抽象数据类型"></a>1.抽象数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ADT Stack&#123; </span><br><span class="line">    数据元素集：D=&#123;ai|ai∈datatype, i=0,1,2, ∙∙∙, n-1, n≥0&#125;</span><br><span class="line">    数据关系集：R=&#123;&lt;ai, ai+1&gt;|ai, ai+1∈D, 0≤i≤n-2&#125;约定an-1为栈顶元素</span><br><span class="line">    基本操作集：P</span><br><span class="line">StackInit(&amp;S)</span><br><span class="line">    操作结果：创建一个空栈S。</span><br><span class="line">ClearStack(&amp;S)</span><br><span class="line">    初始条件：栈S存在。</span><br><span class="line">    操作结果：将S清为空栈。</span><br><span class="line">EmptyStack(S)</span><br><span class="line">    初始条件：栈S存在。</span><br><span class="line">    操作结果：若S为空栈，则返回TRUE(或1)，否则返回FLASE(或0)。</span><br><span class="line">Push(&amp;S, e)</span><br><span class="line">    初始条件：栈S存在且未满。</span><br><span class="line">    操作结果：插入数据元素e，使之成为新栈顶元素。</span><br><span class="line">Pop(&amp;S) </span><br><span class="line">    初始条件：栈S存在且非空。</span><br><span class="line">    操作结果：删除S的栈顶元素并返回其值。</span><br><span class="line">GetTop(S)</span><br><span class="line">    初始条件：栈S存在且非空。</span><br><span class="line">    操作结果：返回栈顶元素的值。</span><br><span class="line">．．．．．．</span><br><span class="line">&#125; ADT Stack;</span><br></pre></td></tr></table></figure><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><h5 id="1）顺序栈"><a href="#1）顺序栈" class="headerlink" title="1）顺序栈"></a>1）顺序栈</h5><p><code>base==top</code>占空标志（还要弹出元素-&gt;下溢）</p><p><code>top-base==stacksize</code>沾满标志（&gt;溢出-&gt;上溢）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line"></span><br><span class="line">struct ElemType &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct SqStack &#123;</span><br><span class="line">    ElemType* base;//或用下标表示</span><br><span class="line">    ElemType* top;</span><br><span class="line">    int stacksize;</span><br><span class="line">&#125;;</span><br><span class="line">bool StackInit(SqStack &amp;S)</span><br><span class="line">&#123;</span><br><span class="line">    S.base = new ElemType[MAXSIZE];</span><br><span class="line">    if (!S.base) return false;</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">bool IsEmpty(SqStack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S.base == S.top)return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line">int StackLength(SqStack S) &#123;</span><br><span class="line">    return (S.top-S.base);</span><br><span class="line">&#125;</span><br><span class="line">bool ClearStack(SqStack&amp; S) &#123;</span><br><span class="line">    if (S.base)S.top = S.base;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">bool DestroyStack(SqStack&amp; S) &#123;</span><br><span class="line">    if (S.base) &#123;</span><br><span class="line">        delete S.base;</span><br><span class="line">        S.stacksize = 0;</span><br><span class="line">        S.base = S.top = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入栈</span><br><span class="line">bool Push(SqStack&amp; S,ElemType e) &#123;</span><br><span class="line">    if (S.top - S.base &gt;= MAXSIZE)return 0;</span><br><span class="line">    *S.top++ = e;//相当于*S.top=e;S.top++;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">//出栈</span><br><span class="line">bool Pop(SqStack&amp; S,ElemType &amp;e) &#123;</span><br><span class="line">    if (S.top == S.base)return 0;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）链栈"><a href="#2）链栈" class="headerlink" title="2）链栈"></a>2）链栈</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line"></span><br><span class="line">struct ElemType &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct StackNode &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    StackNode* next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef StackNode* LinkStack;</span><br><span class="line">void StackInit(LinkStack&amp; S)</span><br><span class="line">&#123;</span><br><span class="line">    S = NULL;//S指向栈顶,不需要头节点，基本不会栈满，空栈相当于头指针指向空；</span><br><span class="line">&#125;</span><br><span class="line">bool IsEmpty(LinkStack&amp; S)</span><br><span class="line">&#123;</span><br><span class="line">    if (!S)return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line">//入栈</span><br><span class="line">bool Push(LinkStack&amp; S, ElemType e) &#123;</span><br><span class="line">    LinkStack p = new StackNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line">    S = p;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">//出栈</span><br><span class="line">bool Pop(LinkStack&amp; S, ElemType&amp; e) &#123;</span><br><span class="line">    if (!S)return 0;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    LinkStack p = S;</span><br><span class="line">    delete p;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">//取栈顶元素</span><br><span class="line">ElemType GetTop(LinkStack&amp; S)&#123;</span><br><span class="line">    if (S) return S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h4><p>1&gt;进制转换</p><p>2&gt;括号匹配的检验</p><p>3&gt;表达式求值</p><h4 id="3-栈与递归"><a href="#3-栈与递归" class="headerlink" title="3.栈与递归"></a>3.栈与递归</h4><p>1）递归</p><p>函数（eg.阶乘、斐波那契数列）+具有递归性质的数据结构（eg.二叉树、广义表）+问题（eg.迷宫问题、汉诺塔问题）</p><p>三个条件：转化为类似的有规律的新问题+转化使其简化+有明确的递归出口或边界</p><p>基本项+归纳项</p><p>2）栈与递归</p><p>递归工作栈</p><p>3）递归到非递归</p><p>方法一：尾递归，单向递归转化为循环</p><p>方法二：用栈实现递归过程</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20250113213402014.png" alt="image-20250113213402014"></p><h3 id="（二）队列（queue-FIFO）"><a href="#（二）队列（queue-FIFO）" class="headerlink" title="（二）队列（queue FIFO）"></a>（二）队列（queue FIFO）</h3><p><strong>“先进先出”</strong>：只能在表尾插入（入队），在表头删除（出队）</p><p>解决问题：eg.脱机打印问题、多用户系统等</p><h4 id="1-抽象数据类型-1"><a href="#1-抽象数据类型-1" class="headerlink" title="1.抽象数据类型"></a>1.抽象数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ADT Queue &#123; </span><br><span class="line">    数据元素集：D=&#123;ai|ai∈datatype, i=0,1,2, ∙∙∙, n-1, n≥0&#125;</span><br><span class="line">    数据关系集：R=&#123;&lt;ai, ai+1&gt;|ai, ai+1∈D, 0≤i≤n-2&#125;约定a0为队头元素， an-1为队尾元素</span><br><span class="line">    基本操作集：P</span><br><span class="line">QueueInit(&amp;Q)</span><br><span class="line">    操作结果：创建一个空队列Q。</span><br><span class="line">ClearQueue(&amp;Q)</span><br><span class="line">    初始条件：队列Q已经存在。</span><br><span class="line">    操作结果：清空队列。</span><br><span class="line">QueueLength(Q)</span><br><span class="line">    初始条件：队列Q已经存在。</span><br><span class="line">    操作结果：返回队列Q的元素个数。队列的定义及其基本操作</span><br><span class="line">EmptyQueue(Q)</span><br><span class="line">    初始条件：队列Q已经存在。</span><br><span class="line">    操作结果：若Q为空队列，则返回TRUE，否则返回FLASE。</span><br><span class="line">FullQueue(Q)</span><br><span class="line">    初始条件：队列Q已经存在。</span><br><span class="line">    操作结果：若Q为已满，则返回TRUE，否则返回FLASE。</span><br><span class="line">EnQueue(&amp;Q, e)</span><br><span class="line">    初始条件：队列Q已经存在且未满。</span><br><span class="line">    操作结果：插入数据元素e，使之成为新队尾元素。</span><br><span class="line">DeQueue(&amp;Q)</span><br><span class="line">    初始条件：队列Q已经存在且非空。</span><br><span class="line">    操作结果：删除Q的队头元素，并返回其值。</span><br><span class="line">GetHead(Q)</span><br><span class="line">    初始条件：队列Q已经存在且非空。</span><br><span class="line">    操作结果：返回队头元素的值。</span><br><span class="line">．．．．．．</span><br><span class="line">&#125; ADT Queue；</span><br></pre></td></tr></table></figure><h4 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h4><h5 id="（一）顺序队列"><a href="#（一）顺序队列" class="headerlink" title="（一）顺序队列"></a>（一）顺序队列</h5><p>存在问题：<code>rear==MAXSIZE</code>，发生溢出（front!=0假溢出）</p><p>解决假上溢问题：1.将元素依次向队头方向移动 2.引入循环队列</p><p>判断队空队满：1.设一个标志 2.记元素个数 3.少用一个元素空间</p><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#define MAXQSIZE 100</span><br><span class="line"></span><br><span class="line">struct ElemType&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct SqQueue &#123;</span><br><span class="line">    ElemType* base;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool InitQueue(SqQueue &amp;S)</span><br><span class="line">&#123;</span><br><span class="line">    S.base = new ElemType[MAXQSIZE];</span><br><span class="line">    if (!S.base)return 0;</span><br><span class="line">    S.front = S.rear = 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">bool IsFull(SqQueue&amp; S)</span><br><span class="line">&#123;</span><br><span class="line">    //少用一个元素空间</span><br><span class="line">    if ((S.rear + 1) % MAXQSIZE == S.front) return 1;</span><br><span class="line">&#125;</span><br><span class="line">bool IsEmpty(SqQueue&amp; S) &#123;</span><br><span class="line">    if (S.front == S.rear)return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line">int Qlength(SqQueue&amp; S) </span><br><span class="line">&#123;</span><br><span class="line">    return ((S.front - S.rear + MAXQSIZE) % MAXQSIZE);</span><br><span class="line">&#125;</span><br><span class="line">bool InsertQueue(SqQueue&amp; Q, const ElemType&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsFull(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;full of Queue&quot; &lt;&lt; endl;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + 1) % MAXQSIZE;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">bool EraseQueue(SqQueue&amp; Q, ElemType&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;no elem to erase&quot; &lt;&lt; endl;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + 1) % MAXQSIZE;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">ElemType GetHead(SqQueue&amp; S)</span><br><span class="line">&#123;</span><br><span class="line">    if (!IsEmpty)return S.base[S.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（二）链式队列"><a href="#（二）链式队列" class="headerlink" title="（二）链式队列"></a>（二）链式队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line"></span><br><span class="line">struct ElemType &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct QNode &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    QNode* next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef QNode* QueuePtr;</span><br><span class="line">struct LinkQueue &#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;;</span><br><span class="line">void InitQueue(LinkQueue&amp; Q) </span><br><span class="line">&#123;</span><br><span class="line">    Q.front = Q.rear = new QNode;</span><br><span class="line">    Q.front-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line">void DextroyQueue(LinkQueue&amp; Q)</span><br><span class="line">&#123;</span><br><span class="line">    while (Q.front) &#123;</span><br><span class="line">        QueuePtr p = (Q.front)-&gt;next;</span><br><span class="line">        free(Q.front);</span><br><span class="line">        Q.front = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void InsertQueue(LinkQueue&amp; Q, const ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr p = new QNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">&#125;</span><br><span class="line">bool E(LinkQueue&amp; Q,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    if (Q.front == Q.rear)return false;</span><br><span class="line">    QueuePtr q = Q.front-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    Q.front-&gt;next = q-&gt;next;</span><br><span class="line">    if (Q.rear == q)Q.rear = Q.front;</span><br><span class="line">    delete q;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h4><p>1&gt;舞会问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构|线性表</title>
      <link href="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><h3 id="（一）数据结构"><a href="#（一）数据结构" class="headerlink" title="（一）数据结构"></a>（一）数据结构</h3><p><img src="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20250105201810969.png" alt="image-20250105201810969"><strong>抽象数据类型的标识和实现:</strong> </p><p>eg. 抽象复数数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Complex &#123;</span><br><span class="line">    double real;</span><br><span class="line">    double imag;</span><br><span class="line"></span><br><span class="line">    Complex(double r=0.0,double i=0.0):real(r),imag(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    double modulus() const &#123;</span><br><span class="line">        return sqrt(real * real + imag * imag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;com1,com2;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    com2.real=1.0;</span><br><span class="line">    com2.imag = 2.0;</span><br><span class="line">    Complex com(1.0,2.0);</span><br><span class="line">    cout &lt;&lt; com.modulus() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; com1.modulus() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; com2.modulus() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）算法"><a href="#（二）算法" class="headerlink" title="（二）算法"></a>（二）算法</h3><h4 id="1-算法性质"><a href="#1-算法性质" class="headerlink" title="1.算法性质"></a>1.算法性质</h4><p>1）有穷性</p><p>2）确定性</p><p>3）可行性</p><p>4）输入</p><p>5）输出</p><h4 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2.算法分析"></a>2.算法分析</h4><p><strong>渐进时间复杂度</strong> <strong>(时间复杂度):</strong><code>T(n)=O(f(n))</code></p><p>1.找执行次数最多的那个基本语句</p><p>2.计算语句频度-&gt;f(n)</p><p>3.<code>O(f(n))</code>表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>比较数量级 同量级</p><p><strong>渐进空间复杂度：</strong><code>S(n)=O(f(n))</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;n/2;i++)&#123;</span><br><span class="line">t=a[i];</span><br><span class="line">a[i]=a[n-i-1];</span><br><span class="line">a[n-i-1]=t;</span><br><span class="line">&#125; //空间复杂度O(1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">b[i]=a[n-i-1];</span><br><span class="line">&#125; </span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">a[i]=b[i];</span><br><span class="line">&#125; </span><br><span class="line">空间复杂度O(n)</span><br></pre></td></tr></table></figure><h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><p><strong>线性表的定义：</strong>包含若干相同类型数据元素的一个线性序列，记为 $L=(a_0,···，a_{i-1},a_i,a_{i+1},···,a_{n-1})$</p><p><strong>线性表的逻辑结构：</strong>$L=(D,R)$</p><p>对于稀疏多项式造成的大量存储浪费，只记不为零的，记录多个元素$P=((p_1,e_1),(p_2,e_2),···,(p_m,e_m))$</p><p>思考：<em>1.数组大小怎么定？</em></p><h3 id="（一）线性表的抽象数据类型"><a href="#（一）线性表的抽象数据类型" class="headerlink" title="（一）线性表的抽象数据类型"></a>（一）线性表的抽象数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//以下不是代码，只是为了方便观看</span><br><span class="line">ADT List&#123;</span><br><span class="line">    数据元素集：D</span><br><span class="line">    数据关系集：R</span><br><span class="line">    基本操作集：P</span><br><span class="line">ListInit(&amp;L)</span><br><span class="line">    操作结果：构建一个空的线性表L</span><br><span class="line">ListDestory(&amp;L)</span><br><span class="line">    初始条件：线性表L存在</span><br><span class="line">    操作结果：撤销线性表L</span><br><span class="line">ListClear(&amp;L)</span><br><span class="line">    初始条件：线性表L存在</span><br><span class="line">    操作结果：将L制成一张空表</span><br><span class="line">ListLength(&amp;L)</span><br><span class="line">    初始条件：线性表L存在</span><br><span class="line">    操作结果：返回L中元素个数（即表长n）</span><br><span class="line">ListEmpty(&amp;L)</span><br><span class="line">    初始条件：线性表L存在</span><br><span class="line">    操作结果：L表为空时返回true，否则返回false</span><br><span class="line">GetElem(L,i)</span><br><span class="line">    初始条件：线性表L存在，且0≤i≤n</span><br><span class="line">    操作结果：返回L中第i个元素的值/指针</span><br><span class="line">LocatedElem(L,e)</span><br><span class="line">    初始条件：线性表L存在，且e∈datatype</span><br><span class="line">    操作结果：若e存在L中，返回e的序号（或指针），否则返回e不在表中的信息（eg.-1/NULL等）</span><br><span class="line">PreElem(L,cur)</span><br><span class="line">    初始条件：线性表L存在，且cur∈datatype</span><br><span class="line">    操作结果：若cur在L中且不是表头，返回cur的前驱，否则返回NULL</span><br><span class="line">SuccElem(L,cur)</span><br><span class="line">    初始条件：线性表L存在，且cur∈datatype</span><br><span class="line">    操作结果：若cur存在L中且不是表尾元素，返回cur的直接后继的值，否则返回NULL</span><br><span class="line">ListInsert(&amp;L,i,e)</span><br><span class="line">    初始条件：线性表L存在，且e∈datatype</span><br><span class="line">    操作结果：若0≤i≤n-1，将e插入到第i个元素之前，表长增加1，函数返回TURE；若i=n，将e插入到表尾，表长增加1，函数返回TURE；i为其他值时函数返回FALSE，L无变化。</span><br><span class="line">ListDel(&amp;L, i)</span><br><span class="line">    初始条件：线性表L存在。</span><br><span class="line">    操作结果：若0≤i≤n-1，将第i个元素从表中删除，函数返回TURE，否则函数返回FALSE，L无变化。</span><br><span class="line">ListTraverse(L)</span><br><span class="line">    初始条件：线性表L存在。</span><br><span class="line">    操作结果：依次对表中的元素利用visit()函数进行访问</span><br><span class="line">&#125;ADT list;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="（二）线性表顺序存储结构"><a href="#（二）线性表顺序存储结构" class="headerlink" title="（二）线性表顺序存储结构"></a>（二）线性表顺序存储结构</h3><p>定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构</p><p>存储位置计算：$LOC(a_{i+1})=LOC(a_1)+(i-1)*l$</p><p>优点：随机访问快，可以直接计算数据元素的地址；存储密度大（结点本身所占存储量/节点结构所占存储量）</p><p>不足：插入、删除效率低，不利于动态增长；浪费存储空间（数组大小可能会定的很大）</p><p>实现(部分)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 1000</span><br><span class="line">typedef char ElemType;</span><br><span class="line">struct SqList</span><br><span class="line">&#123;</span><br><span class="line">    ElemType *elem; //可以typedef char ElemType等等，也可以用结构体，类</span><br><span class="line">    // ElemType data[MAXSIZE];//利用malloc等动态分配数组,*elem第一个元素</span><br><span class="line">    int length;</span><br><span class="line">&#125;;</span><br><span class="line">bool ListInit(SqList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    L.elem = new ElemType[MAXSIZE];</span><br><span class="line">    if (!L.elem)&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListDestory(SqList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    if (L.elem) delete L.elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListClear(SqList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    L.length = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ListLength(SqList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    return L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ListEmpty(SqList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    return (L.length == 0);</span><br><span class="line">&#125;</span><br><span class="line">//查找第i个元素</span><br><span class="line">ElemType GetElem(SqList&amp; L,int i)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &lt;= L.length &amp;&amp; i &gt;= 1)return L.elem[i - 1];</span><br><span class="line">    else return NULL;</span><br><span class="line">&#125;</span><br><span class="line">//查找e元素的位置</span><br><span class="line">int LocatedElem(const SqList&amp; L, const ElemType&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (L.elem[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            return i + 1; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; </span><br><span class="line">    //算法时间复杂度：O(n) (n+1)/2</span><br><span class="line">&#125;</span><br><span class="line">//插入</span><br><span class="line">bool InsertList(SqList&amp; L, const ElemType&amp; e, const int&amp; i)</span><br><span class="line">&#123;</span><br><span class="line">    if (L.length &gt;= MAXSIZE || i&lt;1 || i&gt;L.length + 1)return false;</span><br><span class="line">    else if (i &lt;= L.length) &#123;</span><br><span class="line">        for (int j = L.length - 1; j &gt;= i - 1; j--) &#123;</span><br><span class="line">            L.elem[j + 1] = L.elem[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i - 1] = e;</span><br><span class="line">    L.length += 1;</span><br><span class="line">    return true;</span><br><span class="line">    //算法时间复杂度：O(n)</span><br><span class="line">&#125;</span><br><span class="line">//删除</span><br><span class="line">bool ListDel(SqList&amp; L, const int i)</span><br><span class="line">&#123;</span><br><span class="line">    if (i &lt;= 0 || i &gt; L.length || L.length == 0)return false;</span><br><span class="line">    for (int j = i - 1; j &lt; L.length-1; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j] = L.elem[j + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    return true;</span><br><span class="line">    //时间复杂度O(n);(n-1)/2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：1.<strong>C语言动态内存分配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SaList L;</span><br><span class="line">L.data=(ElemType*)malloc(sizeof(ElemType)*MaxSize)</span><br><span class="line">//加头文件 #include&lt;stdlib.h&gt;</span><br><span class="line">//malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址</span><br><span class="line">//sizeof(x)运算，计算变量x的长度</span><br><span class="line">//free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量</span><br></pre></td></tr></table></figure><p>2.<strong>C++动态存储分配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = new int(10);//申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值:成功:T类型的指针，指向新分配的内存，失败:0(NULL)</span><br><span class="line">delete p1;//释放指针P所指向的内存。P必须是new操作的返回值</span><br></pre></td></tr></table></figure><p>3.<strong>C++参数传递</strong> 省略（值 ；指针变量（可影响也可不影响）；引用类型；数组名 ）</p><h3 id="（三）线性表的链式存储结构"><a href="#（三）线性表的链式存储结构" class="headerlink" title="（三）线性表的链式存储结构"></a>（三）线性表的链式存储结构</h3><p>定义：用物理位置任意的存储单元来存放线性表的数据元素</p><p>结点（数据+指针）+链表（n个结点由指针链组成）包括：单链表，双链表，循环链表</p><p>设头结点的好处：1.便于首元结点的处理 2.便于空表和非空表的统一管理</p><p>顺序表-&gt;随机存取 链表-&gt;顺序存取</p><p>优点：便于插入、删除和动态增长</p><p>劣势：随机访问慢，存储密度小</p><h4 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h4><p><img src="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20250106181404381.png" alt="image-20250106181404381"></p><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*struct ElemType &#123;</span><br><span class="line">    char num[8];</span><br><span class="line">    char name[8];</span><br><span class="line">    int score;</span><br><span class="line">&#125;;//举例,因省去运算符重载，所以以char类型举例*/</span><br><span class="line">typedef char ElemType;</span><br><span class="line">struct Lnode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    Lnode* next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef Lnode *LinkList;//LinkList L;&lt;=&gt;Lnode *L;</span><br><span class="line"></span><br><span class="line">//重载&quot;==&quot;号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">bool InitList(LinkList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    L = new Lnode; //堆区开辟一个头结点</span><br><span class="line">    L-&gt;next = nullptr; </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//建立单链表——头插法</span><br><span class="line">void CreateList_H(LinkList&amp; L, int n)</span><br><span class="line">&#123;</span><br><span class="line">    L = new Lnode;</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    for (int i = n; i &gt;= 1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkList p = new Lnode;</span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;//O(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//建立单链表——尾插法</span><br><span class="line">void CreateList_T(LinkList&amp; L, int n)</span><br><span class="line">&#123;</span><br><span class="line">    L = new Lnode;</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    LinkList r = L;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkList p = new Lnode;</span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;//O(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//判断链表是否为空（空表：链表中没有元素，头节点&amp;指针仍然在（只需要判指针为空））</span><br><span class="line">bool ListEmpty(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    if (L-&gt;next)return 0;</span><br><span class="line">    else return 1;</span><br><span class="line">&#125;</span><br><span class="line">//销毁</span><br><span class="line">void ListDestroy(LinkList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    while (L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        delete p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//清空链表</span><br><span class="line">void ListClear(LinkList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        delete p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    /*q = p-&gt;next;</span><br><span class="line">    delete p;</span><br><span class="line">    while (q) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        delete p;</span><br><span class="line">    &#125;错的,对应while里*/</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line">// 链表表长</span><br><span class="line">int GetLength(const LinkList&amp; L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    while (p)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">    //O(n)</span><br><span class="line">&#125;</span><br><span class="line">//取第i个元素</span><br><span class="line">LinkList GetElem(const LinkList&amp; L, const int&amp; i)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    if (i &lt;= 0)return nullptr;</span><br><span class="line">    while (p-&gt;next&amp;&amp;cnt&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p &amp;&amp; cnt == i) &#123;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;else return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">//按值查找(找地址返回p)</span><br><span class="line">int LocateElem(LinkList&amp; L, ElemType&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    Lnode* p = L-&gt;next;</span><br><span class="line">    size_t cnt = 1;</span><br><span class="line">    while (p)</span><br><span class="line">    &#123;</span><br><span class="line">        if (p-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            return cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;//O(n)</span><br><span class="line">&#125;</span><br><span class="line">//插入</span><br><span class="line">bool InsertList(LinkList&amp; L, const int&amp; i, const ElemType&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (p || j &lt; i - 1) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!p || i &lt; 0)return 0;</span><br><span class="line">    LinkList s = new Lnode;</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s-&gt;next = p -&gt; next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    return 1;//有查找O(n)，没有O(1)</span><br><span class="line">&#125;</span><br><span class="line">//删除第i个结点</span><br><span class="line">bool DelList(LinkList&amp; L, int&amp; i)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while (p || j &lt; i - 1) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next) || i &lt; 0 ||!p)return 0;</span><br><span class="line">    LinkList q;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    delete q;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-单向循环链表"><a href="#3-单向循环链表" class="headerlink" title="3.单向循环链表"></a>3.单向循环链表</h4><p>单链表的首尾节点相连</p><p>注意：1.条件判断是否等于头指针，而非判断是否为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//单链表--------------循环链表</span><br><span class="line">//while(p)---------&gt;while(p!=L)</span><br><span class="line">//while(p-&gt;next)---&gt;while(p-&gt;next!=L)</span><br></pre></td></tr></table></figure><p>2.两种(1)头指针表示循环链表</p><p>(2)尾指针表示循环链表（好处：找$a_1$ $a_n$的时间复杂度均为O(1)，<em>表的的操作常在首位位置上进行</em>）</p><p><img src="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20250113153635772.png" alt="image-20250113153635772"></p><p>3.带尾指针循环链表的合并</p><p>1&gt;Tb表头连接到Ta表尾</p><p>2&gt;释放Tb头节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkList Connect(LinkList Ta,LinkList Tb)</span><br><span class="line">&#123;   p=Ta-&gt;next;</span><br><span class="line">    Ta-&gt;next=Tb-&gt;next-&gt;next;</span><br><span class="line">    delete Tb-&gt;next;</span><br><span class="line">    Tb-&gt;next=p;</span><br><span class="line">    return Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-双向链表"><a href="#4-双向链表" class="headerlink" title="4.双向链表"></a>4.双向链表</h4><p><img src="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20250113155851543.png" alt="image-20250113155851543"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p = p-&gt;next-&gt;next</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">struct DuLnode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    DuLnode* next,* prior;</span><br><span class="line">&#125;;</span><br><span class="line">typedef DuLnode* DuLinkList;</span><br><span class="line"></span><br><span class="line">//头插</span><br><span class="line">void CreatListHead(DuLinkList&amp; L, const size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        DuLnode* p = new DuLnode;</span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;prior = L;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        if (p-&gt;next != nullptr) &#123;</span><br><span class="line">            p-&gt;next-&gt;prior = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//尾插</span><br><span class="line">void CreatListTail(DuLinkList&amp; L, const size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    DuLnode* r = L;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        DuLnode* p = new DuLnode;</span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;prior = r;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//查找第i个元素</span><br><span class="line">DuLinkList GetElemP_DuL(DuLinkList&amp; L, const int i)</span><br><span class="line">&#123;</span><br><span class="line">    DuLinkList p = L;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    if (i &lt;= 0)return nullptr;</span><br><span class="line">    while (p-&gt;next &amp;&amp; cnt &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p &amp;&amp; cnt == i) &#123;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    else return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">//插入</span><br><span class="line">bool ListInsert_DuL(DuLinkList&amp; L, const int i, const ElemType&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DuLinkList p;</span><br><span class="line">    if (!(p = GetElemP_DuL(L, i))) return false;</span><br><span class="line">    DuLinkList s = new DuLnode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//删除</span><br><span class="line">bool ListErase_DuL(DuLinkList&amp; L, const int i)</span><br><span class="line">&#123;</span><br><span class="line">    DuLinkList p;</span><br><span class="line">    if (!(p = GetElemP_DuL(L, i))) return false;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    delete p;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-双向循环链表"><a href="#5-双向循环链表" class="headerlink" title="5.双向循环链表"></a>5.双向循环链表</h4><p><img src="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20250113155909649.png" alt="image-20250113155909649"></p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p>(1)<img src="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20250113162055912.png" alt="image-20250113162055912"></p><p>(2)</p><p><img src="/2025/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20250113162802900.png" alt="image-20250113162802900"></p><h3 id="（四）线性表的应用"><a href="#（四）线性表的应用" class="headerlink" title="（四）线性表的应用"></a>（四）线性表的应用</h3><h4 id="1-线性表的合并"><a href="#1-线性表的合并" class="headerlink" title="1.线性表的合并"></a>1.线性表的合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void union(List&amp; La, List Lb) &#123;</span><br><span class="line">    Lal = listLength(La);</span><br><span class="line">    Lbl = ListLength(Lb);</span><br><span class="line">    ElemType e;</span><br><span class="line">    for(int i = 0; i &lt; Lb_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(Lb, i,e);</span><br><span class="line">        if (!LocatedElem(La, e)) Listinsert(&amp;La,++Lal,e);//O(lal*lbl)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-有序表的合并"><a href="#2-有序表的合并" class="headerlink" title="2.有序表的合并"></a>2.有序表的合并</h4><p>(顺序表)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void MergeList_Sq(SqList LA, SqList LB, SqList&amp; LC) &#123;</span><br><span class="line">    ElemType *pa = LA.elem;</span><br><span class="line">    ElemType *pb = LB.elem;</span><br><span class="line">    LC.length = LA.length + LB.length;</span><br><span class="line">    LC.elem = new ElemType[LC.length];</span><br><span class="line">    ElemType *pc = LC.elem;</span><br><span class="line">    ElemType *pa_last = LA.elem + LA.length - 1;</span><br><span class="line">    ElemType *pb_last = LB.elem + LB.length - 1;</span><br><span class="line">    while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123;</span><br><span class="line">        if (*pa &lt;= *pb)*pc++ = *pa++;</span><br><span class="line">        else *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (pa &lt;= pa_last)*pc++ = *pa++; </span><br><span class="line">    while (pb &lt;= pb_last)*pc++ = *pb++;</span><br><span class="line">&#125;//O(lal+lbl)</span><br></pre></td></tr></table></figure><p>（链式表）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> void MergeList_L(LinkList&amp; La, LinkList&amp; Lb, LinkList&amp; Lc) &#123;</span><br><span class="line">    LinkList pa = La-&gt;next;</span><br><span class="line">    LinkList pb = Lb-&gt;next;</span><br><span class="line">    LinkList pc = Lc = La;</span><br><span class="line">    while (pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pa &lt; pb) &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; </span><br><span class="line">            pc-&gt;next = pb; </span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    delete Lb;//O(lal+lbl)空间：O(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h4><p>（一元多项式运算—数组）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void PolyOperate(SqList &amp;L1, SqList &amp;L2, SqList &amp;L3)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; L1.length &amp;&amp; i &lt; L2.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L3.elem[i] = L1.elem[i] + L2.elem[i];</span><br><span class="line">        L3.length += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (L1.length &lt;= L2.length)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = L1.length; j &lt; L2.length; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            L3.elem[j] = L2.elem[j];</span><br><span class="line">            L3.length += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = L2.length; j &lt; L1.length; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            L3.elem[j] = L1.elem[j];</span><br><span class="line">            L3.length += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（稀疏多项式的运算——顺序表）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//数组</span><br><span class="line">void PloyOperate(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span><br><span class="line">&#123;</span><br><span class="line">    Lnode *pa = La-&gt;next;</span><br><span class="line">    Lnode *pb = Lb-&gt;next;</span><br><span class="line">    Lc = La;</span><br><span class="line">    Lnode *pc = Lc;</span><br><span class="line">    while(pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pa-&gt;data.index &lt; pb-&gt;data.index)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pc-&gt;next;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pa-&gt;data.index &gt; pb-&gt;data.index)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pc-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pa-&gt;data.index == pb-&gt;data.index)</span><br><span class="line">        &#123;</span><br><span class="line">            pa-&gt;data.coef += pb-&gt;data.coef;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pc-&gt;next;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = (pa ? pa : pb);</span><br><span class="line">    delete Lb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//链表</span><br><span class="line">struct PNode &#123;</span><br><span class="line">    float coaf;</span><br><span class="line">    int expn;</span><br><span class="line">    struct PNode* next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PNode* Ploynomial;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//链表</span><br><span class="line">void CreatePolyn(Ploynomial&amp; P, int n)</span><br><span class="line">&#123;</span><br><span class="line">    P = new PNode;</span><br><span class="line">    P-&gt;next = NULL;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Ploynomial s = new PNode;</span><br><span class="line">        cin &gt;&gt; s-&gt;coaf &gt;&gt; s-&gt;expn;</span><br><span class="line">        Ploynomial pre = P;</span><br><span class="line">        Ploynomial q = P-&gt;next;</span><br><span class="line">        while (q &amp;&amp; (q-&gt;expn &lt; s-&gt;expn))</span><br><span class="line">        &#123;</span><br><span class="line">            pre = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next = q;</span><br><span class="line">        pre-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void PloyOperate(Ploynomial&amp; La, Ploynomial&amp; Lb, Ploynomial&amp; Lc)</span><br><span class="line">&#123;</span><br><span class="line">    Ploynomial pa = La-&gt;next;</span><br><span class="line">    Ploynomial pb = Lb-&gt;next;</span><br><span class="line">    Ploynomial pc = Lc = La;</span><br><span class="line">    while (pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pa-&gt;expn &lt; pb-&gt;expn)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa; pa = pa-&gt;next; pc = pc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (pa-&gt;expn == pb-&gt;expn) &#123;</span><br><span class="line">            pa-&gt;coaf = pa-&gt;coaf + pb-&gt;coaf;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">            pc = pc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            pc-&gt;next = pb; pb = pb-&gt;next; pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = (pa ? pa : pb);</span><br><span class="line">    delete Lb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(图书信息管理系统)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Book</span><br><span class="line">&#123;</span><br><span class="line">    string isbn;</span><br><span class="line">    string name;</span><br><span class="line">    float price;</span><br><span class="line">&#125; ElemType;</span><br><span class="line">struct Lnode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    Lnode *next;</span><br><span class="line">&#125; *LinkList;</span><br><span class="line">//各操作与以上单链表等操作类似</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch-数据加载预处理</title>
      <link href="/2024/12/22/Pytorch-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%A4%84%E7%90%86/"/>
      <url>/2024/12/22/Pytorch-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="PyTorch–数据加载和处理"><a href="#PyTorch–数据加载和处理" class="headerlink" title="PyTorch–数据加载和处理"></a>PyTorch–数据加载和处理</h2><h3 id="一、数据处理与加载"><a href="#一、数据处理与加载" class="headerlink" title="一、数据处理与加载"></a>一、数据处理与加载</h3><p> <strong>torch.utils.data.Dataset</strong> 和 <strong>torch.utils.data.DataLoader</strong>是pytorch中高效地处理数据，帮助我们管理数据集、批量加载和数据增强的强大工具。</p><p><strong>full-batch:</strong>直接加载所有的样本数据.</p><p><strong>mini-batch:</strong>将样本数据分成等量的子集，训练或测试时将所有子集进行迭代，遍历完所有的样本后算作一个epoch.</p><p>mini-batch优点：可以加快训练速度；可以更有效地更新模型参数，克服鞍点；减少内存占用，尤其是处理大型数据集时，不需要一次性将整个数据集加载到内存中。</p><p>Mini-Batch 的缺点：由于每次梯度下降只使用部分数据，可能导致模型的精度较低；在训练过程中，损失函数可能会出现上下波动，但总体趋势是下降的。</p><p><strong>epoch:</strong>所有的训练次数</p><p><strong>batch-size:</strong>一次训练用的数据</p><p><strong>iteration:</strong>内层迭代</p><h4 id="1-dataset"><a href="#1-dataset" class="headerlink" title="1.dataset"></a>1.dataset</h4><p>通过继承 <code>torch.utils.data.Dataset</code>这个抽象类 来加载自己的数据集。</p><h5 id="Dataset-两种使用方式"><a href="#Dataset-两种使用方式" class="headerlink" title="Dataset 两种使用方式"></a>Dataset 两种使用方式</h5><ol><li><strong>将所有数据一次性加载进内存</strong>：适用于数据规模较小的场景。</li><li><strong>按需加载数据</strong>：适用于数据量较大的场景，如图像或语音数据，按索引逐批加载，节约内存。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class DiadetsDataset(Dataset):</span><br><span class="line">    def __init__(self):#初始化</span><br><span class="line">        pass</span><br><span class="line">    def __getitem__(self, index):#索引</span><br><span class="line">        pass</span><br><span class="line">    def __len__(self):#长度</span><br><span class="line">        pass</span><br><span class="line">dataset = DiadetsDataset()</span><br></pre></td></tr></table></figure><h3 id="2、dataLoader"><a href="#2、dataLoader" class="headerlink" title="2、dataLoader"></a>2、dataLoader</h3><p><code>DataLoader</code> 按批次加载数据，支持多线程加载并进行数据打乱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">train_loader = DataLoader(dataset=dataset,</span><br><span class="line">                          batch_size=32,</span><br><span class="line">                          shuffle=True,   #指定batch_size，如果需要打乱数据，shuffle=True</span><br><span class="line">                          num_workers=2)#num_workers个并行进程</span><br><span class="line"></span><br><span class="line">#for epoch in range(100):</span><br><span class="line">#for i,data in enumerate(train_loader,0):</span><br><span class="line">#这样windows下会报错</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for epoch in range(100):</span><br><span class="line">        for i,data in enumerate(train_loader,0):</span><br></pre></td></tr></table></figure><h3 id="三、完整代码示例"><a href="#三、完整代码示例" class="headerlink" title="三、完整代码示例"></a>三、完整代码示例</h3><p>刘二大人PyTorch深度学习实践 完整代码(利用matplotlib库进行可视化)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import torch</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from torch.utils.data import Dataset  # 是一个抽象类，只能继承，不能实例化</span><br><span class="line">from torch.utils.data import DataLoader</span><br><span class="line"></span><br><span class="line">class DiadetesDataset(Dataset):</span><br><span class="line">    def __init__(self, filepath):</span><br><span class="line">        xy = np.loadtxt(filepath, delimiter=&#x27;,&#x27;, dtype=np.float32)</span><br><span class="line">        self.len = xy.shape[0]</span><br><span class="line">        self.x_data = torch.from_numpy(xy[:, :-1])</span><br><span class="line">        self.y_data = torch.from_numpy(xy[:, [-1]])</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        return self.x_data[index], self.y_data[index]</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return self.len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = DiadetesDataset(&#x27;./data/diabetes.csv.gz&#x27;)</span><br><span class="line">train_loader = DataLoader(dataset=dataset,</span><br><span class="line">                          batch_size=32,</span><br><span class="line">                          shuffle=True,</span><br><span class="line">                          num_workers=2)  # num_workers个并行进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Model(torch.nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(8, 6)</span><br><span class="line">        self.linear2 = torch.nn.Linear(6, 4)</span><br><span class="line">        self.linear3 = torch.nn.Linear(4, 1)</span><br><span class="line">        self.sigmoid = torch.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = self.sigmoid(self.linear1(x))</span><br><span class="line">        x = self.sigmoid(self.linear2(x))</span><br><span class="line">        x = self.sigmoid(self.linear3(x))  # 这样可以一直用x</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=&#x27;mean&#x27;)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=0.001) </span><br><span class="line"></span><br><span class="line">epoch_list = []</span><br><span class="line">loss_list = []</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for epoch in range(100):</span><br><span class="line">        total_loss = 0.0</span><br><span class="line">        for i, data in enumerate(train_loader, 0):</span><br><span class="line">            inputs, labels = data  # 自动变成tensor</span><br><span class="line">            y_pred = model(inputs)</span><br><span class="line">            loss = criterion(y_pred, labels)</span><br><span class="line">            total_loss += loss</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        average_loss = total_loss / len(train_loader)</span><br><span class="line">        epoch_list.append(epoch)</span><br><span class="line">        loss_list.append(average_loss)</span><br><span class="line">        print(&quot;Epoch:&quot;, epoch, &quot;average loss:&quot;, average_loss)</span><br><span class="line"></span><br><span class="line">    # 训练完后绘制损失曲线</span><br><span class="line">    # 如果 epoch_list 和 loss_list 是 Tensor</span><br><span class="line">    epoch_list = np.array(epoch_list)  # 将 epoch_list 转换为 numpy 数组</span><br><span class="line">    loss_list = [loss.detach().numpy() for loss in loss_list]  # 对 loss_list 中的每个 tensor 进行转换</span><br><span class="line">    plt.plot(epoch_list, loss_list, label=&#x27;Loss Curve&#x27;, marker=&#x27;o&#x27;) </span><br><span class="line">    plt.xlabel(&#x27;Epoch&#x27;)</span><br><span class="line">    plt.ylabel(&#x27;Loss&#x27;)</span><br><span class="line">    plt.title(&#x27;Loss Curve&#x27;)</span><br><span class="line">    plt.legend() </span><br><span class="line">    plt.grid(True)  </span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2024/12/22/Pytorch-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%A4%84%E7%90%86/image-20241222190646212.png" alt="image-20241222190646212"></p><p><img src="/2024/12/22/Pytorch-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%A4%84%E7%90%86/image-20241222194143565.png" alt="image-20241222194143565"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建hexo+github pages避坑</title>
      <link href="/2024/09/21/hexo-github/"/>
      <url>/2024/09/21/hexo-github/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建hexo-github-pages避坑"><a href="#个人博客搭建hexo-github-pages避坑" class="headerlink" title="个人博客搭建hexo+github pages避坑"></a>个人博客搭建hexo+github pages避坑</h1><p>这是我尝试写的第一篇博客，因为刚刚搭建的博客，搭建过程也是遇到了一些问题，搭建流程网上基本都有，在这儿就分享一些我遇到的问题，及最终的解决办法。</p><h2 id="一、域名DNS检查不通过"><a href="#一、域名DNS检查不通过" class="headerlink" title="一、域名DNS检查不通过"></a>一、域名DNS检查不通过</h2><p>我用的是阿里云的域名，其中注意：</p><p>1.要进行域名持有者的<strong>实名认证</strong></p><p>2.要进行<strong>域名过户</strong>邮箱的实名认证</p><p>3.添加 CNAME 记录时，</p><p><strong>主机记录：</strong>填写www(eg.我填的blog 注意这里不要选@)</p><p><strong>记录类型：</strong>选择 CNAME（别名的意思）</p><p><strong>记录值：</strong>填写 用户名.github.io（写用户名，注意不是仓库名）</p><h2 id="二、本地和用户名-github-io加载没有问题，更改域名后css-js无法加载"><a href="#二、本地和用户名-github-io加载没有问题，更改域名后css-js无法加载" class="headerlink" title="二、本地和用户名.github.io加载没有问题，更改域名后css,js无法加载"></a>二、本地和用户名.github.io加载没有问题，更改域名后css,js无法加载</h2><p>原因：<strong>路径错误</strong></p><p>更改域名之前使用用户名.github.io加载应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://用户名.github.io</span><br><span class="line">root: /仓库名.github.io/</span><br></pre></td></tr></table></figure><p>更改域名之后应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://blog.brisrcu.cn</span><br><span class="line">root: / #这儿不要再写仓库名了</span><br></pre></td></tr></table></figure><h2 id="三、修改主题后网页没有变化"><a href="#三、修改主题后网页没有变化" class="headerlink" title="三、修改主题后网页没有变化"></a>三、修改主题后网页没有变化</h2><p>修改主题主要是通过修改主题里的_config.yml文件来完成的，像这个路径是没问题的(D:\app\Hexo\blog\themes\butterfly\ _config.yml)，正常修改是没问题的，没有变化主要是网络的原因，还有像新发一篇博客或修改内容，它加载上去都是需要一定时间的，我当时是以为我的这个文件放的位置的问题，但是得注意的是<strong>注意该文件编写时的缩进等的问题</strong>（缩进出错 hexo clean/g/d时也会报错）。</p><h2 id="四、图片加载过慢"><a href="#四、图片加载过慢" class="headerlink" title="四、图片加载过慢"></a>四、图片加载过慢</h2><p>这个主要是图片较大造成的，可以考虑以下几个优化措施：（我当时是直接通过压缩图片和调格式优化的）</p><p> <strong>1. 压缩图片</strong></p><ul><li><strong>使用图片压缩工具</strong>：可以使用工具如 <a href="https://tinypng.com/">TinyPNG</a> 或 <a href="https://imageoptim.com/">ImageOptim</a> 来压缩图片文件大小，而不明显降低质量。</li><li><strong>调整图片格式</strong>：使用合适的图片格式，比如 JPEG 对于照片，PNG 对于透明背景，WebP 对于高压缩比和质量（webp比较建议）。</li></ul><p><strong>2. 图片尺寸</strong></p><ul><li><strong>调整图片尺寸</strong>：确保图片的实际尺寸与显示尺寸匹配。不要使用比实际显示需要的大图像。</li><li><p><strong>使用响应式图片</strong>：根据设备屏幕的大小，使用不同尺寸的图片，以减少不必要的下载。</p><p><strong>3. 图片加载方式</strong></p></li><li><p><strong>使用懒加载</strong>：通过懒加载技术，只在用户滚动到图片位置时才加载图片。可以使用 <code>loading=&quot;lazy&quot;</code> 属性或 JavaScript 插件来实现。</p><p><strong>懒加载设置过程：</strong></p><p>（1）设置hexo-lazyload-image模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><p>（2）在站点配置文件_config.yml增加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  enable: true</span><br><span class="line">  onlypost: false # 是否仅文章中的图片做懒加载, 如果为 false, 则主题中的其他图片, 也会做懒加载, 如头像, logo 等任何图片.</span><br><span class="line">  loadingImg: /images/loading.png # 图片未加载时的代替图（不填写使用默认加载图片）</span><br></pre></td></tr></table></figure></li><li><p><strong>异步加载图片</strong>：考虑使用异步加载图片的方法，尤其是在较大的图片或图像库中。</p></li></ul><p><strong>4. 内容分发网络 (CDN)</strong></p><ul><li><p><strong>使用 CDN</strong>：将图片和其他静态资源托管在 CDN 上，这样可以利用 CDN 的分发节点加速资源的加载速度。常见的 CDN 服务商有 Cloudflare、AWS CloudFront 和 Akamai。</p><p><strong>以Cloudflare为例：</strong></p><p>（1）注册 Cloudflare 账户并登录。</p><p>（2）添加站点，输入您的博客域名，并选择免费套餐。</p><p>（3）Cloudflare 会自动扫描现有的 DNS 记录，你可以手动检查或添加记录。关键是确保以下几条记录：</p><ul><li><strong>CNAME 记录</strong>：如果你使用 GitHub Pages 的默认二级域名（如 <code>username.github.io</code>），确保 CNAME 记录正确指向 GitHub Pages。</li><li><strong>A 记录</strong>：如果你使用自定义域名，确保 A 记录指向 GitHub 提供的 IP 地址（<code>185.199.108.153</code>, <code>185.199.109.153</code>, <code>185.199.110.153</code>, <code>185.199.111.153</code>），并启用 Cloudflare 的 CDN（小云朵图标应该是橙色）。</li></ul><p>（4）更改域名的 DNS 服务器：你需要前往你购买域名的注册商平台，更新域名的 DNS 服务器为Cloudflare 提供的 DNS</p><p>（5）启用 SSL/TLS 和 CDN 缓存：在 Cloudflare 仪表盘中，根据自身需求设置</p><p>（6）Cloudflare发送邮件给你后，not active将变成active</p><p><strong>5. 图片缓存</strong></p></li><li><p><strong>设置缓存头</strong>：配置服务器发送合适的缓存头（如 <code>Cache-Control</code> 和 <code>Expires</code>），使浏览器可以缓存图片，减少重复加载。</p></li><li><p><strong>版本控制</strong>：在图片文件名中加入版本号或哈希值，以确保浏览器加载最新的图片，同时缓存旧的图片。</p><p><strong>6. 代码优化</strong></p></li><li><p><strong>减少图片请求数</strong>：尽量合并图片，比如使用雪碧图（sprite images），减少 HTTP 请求数量。</p></li><li><strong>优化网页加载顺序</strong>：确保图片的加载不阻塞页面的其他内容，合理安排资源的加载顺序。</li></ul><h2 id="五、出现重定向错误"><a href="#五、出现重定向错误" class="headerlink" title="五、出现重定向错误"></a>五、出现重定向错误</h2><p>造成重定向错误其中一种原因可能是使用CDN加速后SSL/TLS配置的问题。<br><img src="/2024/09/21/hexo-github/1.png" alt></p><p>在 Cloudflare 等 CDN 平台中，SSL/TLS 的加密模式可能会导致循环重定向。通常有三种模式：</p><p>（1）Flexible (灵活模式)：CDN 和用户之间使用 HTTPS，但 CDN 和你的服务器之间使用 HTTP。这可能会导致重定向问题，特别是当你的服务器强制 HTTPS 时。</p><p>（2）Full (完全模式)：CDN 和服务器之间使用 HTTPS 进行通信，但不会验证证书。这种模式通常更安全且不会导致重定向循环。</p><p>（3）Full (strict) (完全严格模式)：CDN 和服务器之间使用 HTTPS 并验证证书，这需要确保你的服务器上有有效的 SSL 证书。</p><p>解决方案：如果使用的是Flexible模式，建议切换到 Full 模式或 Full (strict) 模式，避免 HTTPS 重定向冲突。</p><p>1.打开Cloudflare，点进SSL/TLS，见Current encryption mode:Flexible ，需要更改，点击Configure</p><p><img src="/2024/09/21/hexo-github/hello%20world-SSLTLS.png" alt></p><ol><li>进入如下界面后，将Flexible改为Full或Full(Strict)，若为上述原因造成的重定向错误，到这里即可解决</li></ol><p><img src="/2024/09/21/hexo-github/hello%20world-full.png" alt></p><p>以上就是我搭建博客过程中遇到的一些问题（为什么我遇到的问题这么多，可能是因为我不好好按教程在那儿瞎点吧，还有为什么只有后边一点有图片，主要是当时我真忘截图了，可能还有点懒的因素在里边），<strong>但最重要的：如果您也遇到了类似的问题，希这些望能够对您有所帮助！</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
